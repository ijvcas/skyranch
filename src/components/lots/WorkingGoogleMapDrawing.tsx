
import React, { useEffect, useState, useRef } from 'react';
import { type Lot } from '@/stores/lotStore';
import { useSimplePolygonDrawing } from '@/hooks/useSimplePolygonDrawing';
import SimplifiedPolygonControls from './controls/SimplifiedPolygonControls';
import MapLotLabelsControl from './controls/MapLotLabelsControl';
import { toast } from 'sonner';
import MapContainer from '@/components/common/MapContainer';
import FitBoundsButton from '@/components/common/FitBoundsButton';

interface WorkingGoogleMapDrawingProps {
  lots: Lot[];
  onLotSelect: (lotId: string) => void;
}

const SKYRANCH_CENTER = { lat: 40.31764444, lng: -4.47409722 };
const SKYRANCH_NAME = "SkyRanch";

const WorkingGoogleMapDrawing = ({ lots, onLotSelect }: WorkingGoogleMapDrawingProps) => {
  const {
    mapRef,
    mapInstance,
    isMapReady,
    polygons,
    selectedLotId,
    isDrawing,
    startDrawing,
    stopDrawing,
    deletePolygon,
    getLotColor,
    debugLots
  } = useSimplePolygonDrawing({ lots, onLotSelect });
  
  // Toggle states for label visibility - load from localStorage
  const [showPropertyLots, setShowPropertyLots] = useState(() => {
    const saved = localStorage.getItem('etiquetas-show-property-lots');
    return saved ? JSON.parse(saved) : true;
  });
  
  const [showPastureLots, setShowPastureLots] = useState(() => {
    const saved = localStorage.getItem('etiquetas-show-pasture-lots');
    return saved ? JSON.parse(saved) : true;
  });
  
  // Property name label should be hidden by default on Potreros map
  const [showPropertyName, setShowPropertyName] = useState(() => {
    const saved = localStorage.getItem('etiquetas-show-property-name');
    return saved ? JSON.parse(saved) : false;
  });

  // Save toggle states to localStorage when they change
  useEffect(() => {
    localStorage.setItem('etiquetas-show-property-lots', JSON.stringify(showPropertyLots));
  }, [showPropertyLots]);

  useEffect(() => {
    localStorage.setItem('etiquetas-show-pasture-lots', JSON.stringify(showPastureLots));
  }, [showPastureLots]);

  useEffect(() => {
    localStorage.setItem('etiquetas-show-property-name', JSON.stringify(showPropertyName));
  }, [showPropertyName]);
  const [isMobile, setIsMobile] = useState(false);
  const labelsRef = useRef<{[key: string]: google.maps.Marker}>({});
  const propertyLabelRef = useRef<google.maps.Marker | null>(null);

  // Debug lots when component loads
  useEffect(() => {
    console.log('üîç WorkingGoogleMapDrawing: Total lots received:', lots.length);
    console.log('üîç Raw lots data:', lots);
    const autoGeneratedLots = lots.filter(lot => lot.autoGenerated === true);
    const userCreatedLots = lots.filter(lot => lot.autoGenerated !== true);
    console.log('üè¢ Auto-generated (property) lots:', autoGeneratedLots.length, autoGeneratedLots.map(l => l.name));
    console.log('üåø User-created (pasture) lots:', userCreatedLots.length, userCreatedLots.map(l => l.name));
  }, [lots]);

  // Detect mobile devices
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  // Create or update lot labels on the map - now includes dependency on lot names and separate toggles
  useEffect(() => {
    if (!isMapReady || !mapInstance) return;

    // Clear existing labels if both toggles are off
    if (!showPropertyLots && !showPastureLots) {
      Object.values(labelsRef.current).forEach(label => {
        label.setMap(null);
      });
      labelsRef.current = {};
      return;
    }

    // Create or update lot labels
    lots.forEach(lot => {
      const isPropertyLot = lot.autoGenerated === true;
      const isPastureLot = lot.autoGenerated !== true;
      
      // Check if this lot type should be shown
      // Business rule: Show labels based on their type and toggle state
      const shouldShow = (isPropertyLot && showPropertyLots) || (isPastureLot && showPastureLots);
      
      if (!shouldShow) {
        // Remove label if it exists but shouldn't be shown
        if (labelsRef.current[lot.id]) {
          labelsRef.current[lot.id].setMap(null);
          delete labelsRef.current[lot.id];
        }
        return;
      }
      
      // Skip if no polygon - check if polygon exists for this lot
      const lotPolygon = polygons.get(lot.id);
      if (!lotPolygon) {
        console.log(`‚ö†Ô∏è No polygon found for lot: ${lot.name}, skipping label creation`);
        return;
      }
      
      // Additional safety check - ensure polygon has a valid path
      const path = lotPolygon.getPath();
      if (!path || typeof path.getLength !== 'function') {
        console.log(`‚ö†Ô∏è Invalid polygon path for lot: ${lot.name}, skipping label creation`);
        return;
      }

      const pathLength = path.getLength();
      if (pathLength === 0) {
        console.log(`‚ö†Ô∏è Empty polygon path for lot: ${lot.name}, skipping label creation`);
        return;
      }
      
      // Calculate centroid of polygon
      let lat = 0, lng = 0;
      
      for (let i = 0; i < pathLength; i++) {
        const point = path.getAt(i);
        if (point && typeof point.lat === 'function' && typeof point.lng === 'function') {
          lat += point.lat();
          lng += point.lng();
        }
      }
      
      lat /= pathLength;
      lng /= pathLength;
      
      // Create or update label with the full lot name
      if (labelsRef.current[lot.id]) {
        labelsRef.current[lot.id].setPosition({ lat, lng });
        labelsRef.current[lot.id].setLabel({
          text: lot.name,
          color: '#ffffff',
          fontSize: '12px',
          fontWeight: '700'
        });
      } else {
        const label = new google.maps.Marker({
          position: { lat, lng },
          map: mapInstance,
          label: {
            text: lot.name,
            color: '#ffffff',
            fontSize: '12px',
            fontWeight: '700'
          },
          icon: {
            path: 'M 0,0 C 0,0 0,0 0,0 Z', // Empty path - just the label
            scale: 1,
          },
          clickable: true
        });
        
        label.addListener('click', () => {
          onLotSelect(lot.id);
        });
        
        labelsRef.current[lot.id] = label;
      }
    });
    
    // Remove labels for deleted polygons
    Object.keys(labelsRef.current).forEach(lotId => {
      if (!polygons.has(lotId)) {
        labelsRef.current[lotId].setMap(null);
        delete labelsRef.current[lotId];
      }
    });
    
  }, [isMapReady, mapInstance, lots, polygons, showPropertyLots, showPastureLots, onLotSelect]);
  
  // Create or update property name label
  useEffect(() => {
    if (!isMapReady || !mapInstance) return;
    
    if (!showPropertyName) {
      if (propertyLabelRef.current) {
        propertyLabelRef.current.setMap(null);
        propertyLabelRef.current = null;
      }
      return;
    }
    
    if (!propertyLabelRef.current) {
      propertyLabelRef.current = new google.maps.Marker({
        position: SKYRANCH_CENTER,
        map: mapInstance,
        label: {
          text: SKYRANCH_NAME,
          color: '#ffffff',
          fontSize: '16px',
          fontWeight: 'bold'
        },
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 0, // Makes the icon invisible
        }
      });
    } else {
      propertyLabelRef.current.setMap(mapInstance);
    }
    
  }, [isMapReady, mapInstance, showPropertyName]);
  
  // Cleanup labels on unmount
  useEffect(() => {
    return () => {
      Object.values(labelsRef.current).forEach(label => {
        label.setMap(null);
      });
      
      if (propertyLabelRef.current) {
        propertyLabelRef.current.setMap(null);
      }
    };
  }, []);

  // Handle polygon deletions - show toast message
  const handleDeletePolygon = async (lotId: string) => {
    try {
      await deletePolygon(lotId);
      toast.success('Pol√≠gono eliminado correctamente');
    } catch (error) {
      console.error('Error deleting polygon:', error);
      toast.error('Error al eliminar el pol√≠gono');
    }
  };

  // Clear only user-created (pasture) polygons, not property lots
  const handleClearPastureLots = () => {
    console.log('üßπ Clearing pasture lots...');
    const pastureLots = lots.filter(lot => lot.autoGenerated !== true);
    console.log('üåø Pasture lots to clear:', pastureLots.length);
    pastureLots.forEach(lot => {
      const polygon = polygons.get(lot.id);
      if (polygon) {
        console.log('üóëÔ∏è Removing polygon for pasture lot:', lot.name);
        polygon.setMap(null);
      }
    });
  };

  // Handle starting drawing for a specific lot
  const handleStartDrawing = (lotId: string) => {
    console.log('üéØ Starting drawing for lot:', lotId);
    startDrawing(lotId);
  };

  // Calculate polygon count from Map
  const polygonCount = polygons.size;

  // Fit map to all rendered polygons
  const handleFitBounds = () => {
    if (!isMapReady || !mapInstance || polygons.size === 0) return;
    const bounds = new google.maps.LatLngBounds();
    polygons.forEach((polygon) => {
      const path = polygon.getPath();
      if (path) {
        path.forEach((latLng: google.maps.LatLng) => bounds.extend(latLng));
      }
    });
    mapInstance.fitBounds(bounds);
  };

  // Debug polygon rendering
  useEffect(() => {
    if (isMapReady && polygons.size > 0) {
      console.log('üó∫Ô∏è Current polygons on map:', polygons.size);
      polygons.forEach((polygon, lotId) => {
        const lot = lots.find(l => l.id === lotId);
        if (lot) {
          console.log(`üìç Polygon for lot ${lot.name} (${lot.autoGenerated ? 'auto-generated' : 'user-created'}): visible=${polygon.getVisible()}`);
        }
      });
    }
  }, [isMapReady, polygons, lots]);

  return (
    <MapContainer>
      {/* Loading overlay */}
      {!isMapReady && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-100 z-10">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600 mx-auto mb-4"></div>
            <p className="text-gray-600 font-medium">Inicializando Google Maps...</p>
            <p className="text-sm text-gray-500">Cargando herramientas de dibujo y geometr√≠a</p>
          </div>
        </div>
      )}
      
      {/* Map container with mobile optimizations */}
      <div 
        ref={mapRef} 
        className="w-full h-full" 
        style={{ touchAction: isMobile ? 'manipulation' : 'auto' }}
      />

      {/* Fit bounds control - moved down to avoid being hidden */}
      {isMapReady && (
        <div className="absolute right-4 top-24 z-20">
          <FitBoundsButton onClick={handleFitBounds} />
        </div>
      )}
      
      
      {/* Controls overlay - thin lot count banner at top-center */}
      {isMapReady && (
        <>
          <div className="absolute left-4 top-16 z-20">
            <SimplifiedPolygonControls
              onClearAll={handleClearPastureLots}
              selectedLotId={selectedLotId}
              onDeleteSelected={() => {
                if (selectedLotId) {
                  handleDeletePolygon(selectedLotId);
                }
              }}
              polygonCount={polygonCount}
              lots={lots}
              onStartDrawing={handleStartDrawing}
              isDrawing={isDrawing}
            />
          </div>
          
          <MapLotLabelsControl
              showLabels={showPropertyLots || showPastureLots}
              onToggleLabels={() => {}} // Not used anymore, replaced by individual toggles
              showPropertyName={showPropertyName}
              onTogglePropertyName={setShowPropertyName}
              showPropertyLots={showPropertyLots}
              onTogglePropertyLots={setShowPropertyLots}
              showPastureLots={showPastureLots}
            onTogglePastureLots={setShowPastureLots}
          />
        </>
      )}
    </MapContainer>
  );
};

export default WorkingGoogleMapDrawing;
