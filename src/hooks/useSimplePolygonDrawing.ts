
import { useState, useCallback, useRef, useEffect } from 'react';
import { type Lot } from '@/stores/lotStore';
import { loadGoogleMapsAPI } from './polygon/useGoogleMapsLoader';
import { usePolygonStorage } from './polygon/usePolygonStorage';
import { usePolygonManager } from './polygon/usePolygonManager';
import { useDrawingManager } from './polygon/useDrawingManager';
import { syncPolygonAreasWithLots } from '@/services/polygonService';

interface UseSimplePolygonDrawingOptions {
  lots: Lot[];
  onLotSelect: (lotId: string) => void;
}

const SKYRANCH_CENTER = { lat: 40.31764444, lng: -4.47409722 };

export const useSimplePolygonDrawing = ({ lots, onLotSelect }: UseSimplePolygonDrawingOptions) => {
  const [isMapReady, setIsMapReady] = useState(false);
  
  const mapRef = useRef<HTMLDivElement>(null);
  const mapInstance = useRef<google.maps.Map | null>(null);
  const isInitialized = useRef(false);

  // Get lot color based on auto-generated status
  const getLotColor = useCallback((lot: Lot) => {
    // Auto-generated lots (property lots) - increased opacity for better visibility
    if (lot.autoGenerated === true) {
      return 'rgba(156, 163, 175, 0.6)'; // Increased opacity for property lots
    }
    
    // User-created lots get colors based on status and animal presence - INCREASED OPACITY
    if (lot.currentAnimals && lot.currentAnimals > 0) {
      return 'rgba(59, 130, 246, 0.8)'; // Blue for "En Uso" - INCREASED opacity
    }
    
    if (lot.status === 'resting') {
      return 'rgba(245, 158, 11, 0.8)'; // Amber for "En Descanso" - INCREASED opacity
    }
    
    // Default to available (Disponible)
    return 'rgba(16, 185, 129, 0.8)'; // Green for "Disponible" - INCREASED opacity
  }, []);

  // Storage hooks
  const { loadPolygonsFromStorage } = usePolygonStorage();

  // Polygon manager
  const {
    polygons,
    handlePolygonComplete,
    deletePolygon,
    loadSavedPolygons
  } = usePolygonManager(mapInstance.current, onLotSelect);

  // Drawing manager
  const {
    selectedLotId,
    isDrawing,
    initializeDrawingManager,
    startDrawing,
    stopDrawing
  } = useDrawingManager({
    lots,
    getLotColor,
    onPolygonComplete: handlePolygonComplete
  });

  // Initialize map only once
  useEffect(() => {
    if (isInitialized.current || !mapRef.current) return;

    const initMap = async () => {
      try {
        console.log('ðŸ—ºï¸ Initializing Google Maps (one-time)...');
        await loadGoogleMapsAPI();
        
        const map = new google.maps.Map(mapRef.current, {
          center: SKYRANCH_CENTER,
          zoom: 16,
          mapTypeId: google.maps.MapTypeId.SATELLITE,
          mapTypeControl: true,
          zoomControl: true,
          streetViewControl: false,
          fullscreenControl: true,
          gestureHandling: 'greedy',
          disableDefaultUI: false,
        });

        mapInstance.current = map;
        isInitialized.current = true;

        // Wait for map to be fully loaded
        google.maps.event.addListenerOnce(map, 'idle', () => {
          console.log('âœ… Map ready, initializing drawing manager...');
          initializeDrawingManager(map);
          setIsMapReady(true);
        });

      } catch (error) {
        console.error('âŒ Error initializing map:', error);
      }
    };

    initMap();
  }, []); // Only run once on mount

  // Load polygons when map is ready and lots are available
  useEffect(() => {
    if (!isMapReady || !mapInstance.current || lots.length === 0) return;

    const loadPolygons = async () => {
      console.log('ðŸ”„ Loading polygons for', lots.length, 'lots...');
      
      const autoGeneratedLots = lots.filter(lot => lot.autoGenerated === true);
      const userCreatedLots = lots.filter(lot => lot.autoGenerated !== true);
      
      console.log('ðŸ¢ Auto-generated lots:', autoGeneratedLots.length);
      console.log('ðŸŒ¿ User-created lots:', userCreatedLots.length);
      
      await loadSavedPolygons(lots);
      
      // Sync polygon areas with lots
      await syncPolygonAreasWithLots();
      
      console.log('âœ… Polygon loading complete');
    };

    loadPolygons();
  }, [isMapReady, lots.length]); // Only depend on map readiness and lot count

  // Update polygon colors when lot status changes (animals assigned/removed)
  useEffect(() => {
    if (!isMapReady || !mapInstance.current || lots.length === 0) return;

    console.log('ðŸŽ¨ Updating polygon colors based on lot status changes...');
    
    lots.forEach(lot => {
      const polygon = polygons.get(lot.id);
      if (polygon) {
        // Skip auto-generated lots as they maintain gray color
        if (lot.autoGenerated === true) return;
        
        // Use the same color logic as in loadSavedPolygons
        let fillColor = '#10B981'; // Default green (Disponible)
        if (lot.currentAnimals && lot.currentAnimals > 0) {
          fillColor = '#3B82F6'; // Blue for "En Uso"
        } else if (lot.status === 'resting') {
          fillColor = '#F59E0B'; // Amber for "En Descanso"
        }
        
        console.log(`ðŸŽ¯ Updating color for lot ${lot.name}: ${fillColor} (animals: ${lot.currentAnimals || 0}, status: ${lot.status})`);
        
        polygon.setOptions({
          fillColor: fillColor,
          strokeColor: fillColor,
          fillOpacity: 0.8,
          strokeOpacity: 0.9,
          strokeWeight: 2,
          visible: true // Ensure visibility
        });
        
        // Special debug for P-1
        if (lot.name === 'P-1') {
          console.log('ðŸ” P-1 color update:', {
            fillColor,
            visible: polygon.getVisible(),
            hasMap: !!polygon.getMap()
          });
        }
      } else {
        console.log(`âš ï¸ No polygon found for lot: ${lot.name}, skipping label creation`);
      }
    });
  }, [lots, isMapReady, polygons]); // Simplified dependencies

  return {
    mapRef,
    mapInstance: mapInstance.current,
    isMapReady,
    polygons,
    selectedLotId,
    isDrawing,
    startDrawing,
    stopDrawing,
    deletePolygon,
    getLotColor,
    // Force all polygons to be visible and fit map bounds
    forcePolygonVisibility: useCallback(() => {
      if (!isMapReady || !mapInstance.current || polygons.size === 0) return;
      
      console.log('ðŸ”§ Forcing polygon visibility for', polygons.size, 'polygons...');
      const bounds = new google.maps.LatLngBounds();
      let polygonCount = 0;
      
      polygons.forEach((polygon, lotId) => {
        // Force visibility
        polygon.setVisible(true);
        
        // Add to bounds
        const path = polygon.getPath();
        if (path) {
          path.forEach((latLng: google.maps.LatLng) => bounds.extend(latLng));
        }
        
        polygonCount++;
        console.log(`âœ… Forced visibility for polygon ${lotId}`);
      });
      
      // Fit map to include all polygons
      if (polygonCount > 0) {
        mapInstance.current.fitBounds(bounds);
        console.log(`ðŸ—ºï¸ Fitted map bounds to ${polygonCount} polygons`);
      }
    }, [isMapReady, mapInstance, polygons]),
    
    // Debug function to check lot data and force color update
    debugLots: () => {
      console.log('ðŸ” DEBUG: Current lots data:', lots.map(l => ({ 
        id: l.id, 
        name: l.name, 
        currentAnimals: l.currentAnimals, 
        status: l.status,
        autoGenerated: l.autoGenerated 
      })));
      
      lots.forEach(lot => {
        const color = getLotColor(lot);
        console.log(`ðŸŽ¨ Color for ${lot.name}: ${color}`);
      });
    }
  };
};
