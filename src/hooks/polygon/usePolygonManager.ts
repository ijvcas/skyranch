
import { useState, useCallback } from 'react';
import { saveLotPolygon, deleteLotPolygon, getLotPolygons } from '@/services/polygonService';
import { useLotStore } from '@/stores/lotStore';
import { toast } from 'sonner';

export const usePolygonManager = (
  map: google.maps.Map | null,
  onPolygonClick?: (lotId: string) => void
) => {
  const [polygons, setPolygons] = useState<Map<string, google.maps.Polygon>>(new Map());

  const calculatePolygonArea = useCallback((polygon: google.maps.Polygon): number => {
    const area = google.maps.geometry.spherical.computeArea(polygon.getPath());
    return area / 10000; // Convert from mÂ² to hectares
  }, []);

  const handlePolygonComplete = useCallback(async (
    polygon: google.maps.Polygon, 
    lotId: string
  ) => {
    if (!map) return;

    try {
      console.log(`ðŸŽ¯ Saving polygon for existing lot:`, lotId);
      
      const area = calculatePolygonArea(polygon);
      console.log(`ðŸ“ Calculated area: ${area.toFixed(2)} hectares`);

      // Get coordinates from the polygon
      const path = polygon.getPath();
      const coordinates = path.getArray().map(point => ({
        lat: point.lat(),
        lng: point.lng()
      }));

      // Save polygon to database for the existing lot
      const success = await saveLotPolygon(lotId, coordinates, area);

      if (success) {
        // Set polygon style for user-created lots (colored and interactive)
        polygon.setOptions({
          fillColor: '#10B981',
          fillOpacity: 0.3,
          strokeColor: '#059669',
          strokeWeight: 2,
          strokeOpacity: 0.9,
          editable: false,
          clickable: true
        });

        // Add click listener
        if (onPolygonClick) {
          polygon.addListener('click', () => {
            onPolygonClick(lotId);
          });
        }
        // Hover effects for user-created lots
        polygon.addListener('mouseover', () => {
          polygon.setOptions({ strokeWeight: 3, fillOpacity: 0.4 });
        });
        polygon.addListener('mouseout', () => {
          polygon.setOptions({ strokeWeight: 2, fillOpacity: 0.3 });
        });

        // Add to polygons map
        setPolygons(prev => new Map(prev.set(lotId, polygon)));
        
        toast.success(`PolÃ­gono guardado exitosamente`);
      } else {
        polygon.setMap(null);
        toast.error('Error al guardar el polÃ­gono');
      }
    } catch (error) {
      console.error('âŒ Error saving polygon:', error);
      polygon.setMap(null);
      toast.error('Error al guardar el polÃ­gono');
    }
  }, [map, calculatePolygonArea, onPolygonClick]);

  const loadSavedPolygons = useCallback(async (lots: any[], customOptions?: any) => {
    if (!map || !lots.length) {
      console.log('âš ï¸ Cannot load polygons: no map or no lots');
      return;
    }

    try {
      console.log('ðŸ”„ Loading saved polygons for lots...', lots.length);
      const polygonData = await getLotPolygons();
      console.log('ðŸ“Š Retrieved polygon data:', polygonData.length);
      
      // Clear existing polygons before loading new ones
      polygons.forEach(polygon => polygon.setMap(null));
      const newPolygons = new Map<string, google.maps.Polygon>();
      
      lots.forEach((lot) => {
        const data = polygonData.find(p => p.lot_id === lot.id);
        if (!data?.coordinates) {
          console.log(`âš ï¸ No polygon data found for lot: ${lot.name} (${lot.id})`);
          return;
        }

        try {
          const coordinates = typeof data.coordinates === 'string' 
            ? JSON.parse(data.coordinates) 
            : data.coordinates;

          if (!Array.isArray(coordinates) || coordinates.length === 0) {
            console.log(`âš ï¸ Invalid coordinates for lot: ${lot.name}`);
            return;
          }

          const path = coordinates.map((coord: any) => ({
            lat: parseFloat(coord.lat || coord.latitude || coord[0]),
            lng: parseFloat(coord.lng || coord.longitude || coord[1])
          }));

          // Determine styling based on autoGenerated flag and lot status
          const isAutoGenerated = (lot as any).autoGenerated === true;
          console.log(`ðŸŽ¨ Creating polygon for ${isAutoGenerated ? 'auto-generated' : 'user-created'} lot: ${lot.name} (animals: ${lot.currentAnimals || 0}, status: ${lot.status})`);
          
          // Use dynamic colors for user-created lots based on status and animals
          let polygonOptions;
          if (isAutoGenerated) {
            polygonOptions = {
              // Auto-generated lots: Gray, non-editable (property lots)
              fillColor: '#E5E7EB',
              fillOpacity: 0.15,
              strokeColor: '#6B7280',
              strokeWeight: 2,
              strokeOpacity: 0.8,
              editable: false,
              clickable: false
            };
          } else {
            // User-created lots: Dynamic colors based on status and animals
            let fillColor = '#10B981'; // Default green (Disponible)
            if (lot.currentAnimals && lot.currentAnimals > 0) {
              fillColor = '#3B82F6'; // Blue for "En Uso"
            } else if (lot.status === 'resting') {
              fillColor = '#F59E0B'; // Amber for "En Descanso"
            }
            
            polygonOptions = {
              fillColor: fillColor,
              fillOpacity: 0.8, // Higher opacity for better visibility
              strokeColor: fillColor,
              strokeWeight: 2,
              strokeOpacity: 0.9,
              editable: false,
              clickable: true,
              visible: true // Explicitly set visible
            };
          }

          const polygon = new google.maps.Polygon({
            paths: path,
            map: map,
            ...polygonOptions
          });

          // Add click listener only for user-created lots
          if (!isAutoGenerated && onPolygonClick) {
            polygon.addListener('click', () => {
              console.log(`ðŸ–±ï¸ Polygon clicked for user-created lot: ${lot.name}`);
              onPolygonClick(lot.id);
            });
          }
          
          // Hover effects for user-created lots only
          if (!isAutoGenerated) {
            polygon.addListener('mouseover', () => {
              polygon.setOptions({ strokeWeight: 3, fillOpacity: 0.9 });
            });
            polygon.addListener('mouseout', () => {
              polygon.setOptions({ strokeWeight: 2, fillOpacity: 0.8 });
            });
          }

          // Store in the new polygons map
          newPolygons.set(lot.id, polygon);
          console.log(`âœ… Loaded polygon for ${isAutoGenerated ? 'property' : 'pasture'} lot: ${lot.name}, visible: ${polygon.getVisible()}`);
        } catch (error) {
          console.error(`âŒ Error parsing coordinates for lot ${lot.name}:`, error);
        }
      });
      
      // Update the state with all new polygons at once
      setPolygons(newPolygons);
      console.log(`ðŸŽ¯ Total polygons loaded: ${newPolygons.size}`);
      
      // Special debug for P-1
      const p1Polygon = newPolygons.get('61cb0814-319f-43e8-9436-08c589899f55');
      if (p1Polygon) {
        console.log('ðŸ” P-1 polygon loaded successfully:', {
          visible: p1Polygon.getVisible(),
          map: !!p1Polygon.getMap(),
          fillColor: p1Polygon.get('fillColor'),
          fillOpacity: p1Polygon.get('fillOpacity')
        });
      } else {
        console.error('âŒ P-1 polygon not loaded! Checking data...');
        const p1Data = polygonData.find(p => p.lot_id === '61cb0814-319f-43e8-9436-08c589899f55');
        console.log('P-1 data from database:', p1Data);
      }
      
    } catch (error) {
      console.error('âŒ Error loading saved polygons:', error);
    }
  }, [map, onPolygonClick]);

  const deletePolygon = useCallback(async (lotId: string) => {
    const polygon = polygons.get(lotId);
    if (polygon) {
      polygon.setMap(null);
      setPolygons(prev => {
        const newMap = new Map(prev);
        newMap.delete(lotId);
        return newMap;
      });

      try {
        await deleteLotPolygon(lotId);
        console.log(`ðŸ—‘ï¸ Deleted polygon for lot: ${lotId}`);
      } catch (error) {
        console.error('âŒ Error deleting polygon from database:', error);
      }
    }
  }, [polygons]);

  const clearAllPolygons = useCallback(() => {
    console.log('ðŸ§¹ Clearing all polygons from map...');
    polygons.forEach(polygon => polygon.setMap(null));
    setPolygons(new Map());
  }, [polygons]);

  const updatePolygonVisibility = useCallback((lotId: string, visible: boolean) => {
    const polygon = polygons.get(lotId);
    if (polygon) {
      polygon.setVisible(visible);
    }
  }, [polygons]);

  return {
    polygons,
    handlePolygonComplete,
    loadSavedPolygons,
    deletePolygon,
    clearAllPolygons,
    updatePolygonVisibility
  };
};
